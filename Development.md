下面是一份基于你 **Cookmate** 项目现状的 “从 0 到 可用” 开发思路，分为 4 个阶段、12 个里程碑，并穿插关键技术决策与落地建议。你可以按需拆分为短迭代（1–2 周）来执行。

---

## 🌱 阶段 0：澄清目标 & 基础设施

| 里程碑             | 目的                                 | 产出                                                       |
| --------------- | ---------------------------------- | -------------------------------------------------------- |
| **M0-1　MVP 清单** | 把 README 中的功能按“上线必需 / 后续增强”两档再梳理一次 | 两张表：功能 MVP & 待迭代 backlog                                 |
| **M0-2　开发基础设施** | 搭通最小可用的 CI / 质量门禁                  | `ruff + mypy + pytest` 在 GitHub Actions 通过；pre-commit 钩子 |

> **鸡血一句：** *“先让代码能跑、能测、能查。”* 你会在后面反复受益。

---

## 🛠️ 阶段 1：Domain & 内存实现（无 I/O）

> 目标：**可在 Python REPL 中录菜 → 扣库存 → 生成购物清单**，完全不触磁盘。

| 里程碑                       | 关键任务                                                                                    | 建议库 / 方法                                     |
| ------------------------- | --------------------------------------------------------------------------------------- | -------------------------------------------- |
| **M1-1　领域模型**             | `Recipe`, `Ingredient`, `InventoryItem` 聚合根<br>值对象：`Quantity`, `Unit`, `ExpirationDate` | 纯 Python dataclass / Pydantic v2 `BaseModel` |
| **M1-2　领域服务**             | `CookService`（校验 & 扣减）<br>`PlannerService`（按已有食材筛选可做菜）                                  | 函数式 + 小型策略模式                                 |
| **M1-3　Memory Repo + DI** | 写 `repo_memory`，注入到服务层                                                                  | `typing.Protocol` 先定义 Port                   |
| **M1-4　单元测试**             | 覆盖服务 & repo 分支                                                                          | pytest parametrize + hypothesis              |

**完成标志**： 在 `tests/` 里模拟做两道菜，能看到库存扣减与缺料列表生成。

---

## 🗂️ 阶段 2：持久化 & 适配层

> 目标：**CLI→SQLite** 全流程打通；为后续 Web/前端留好缝隙。

| 里程碑                  | 关键任务                                                       | 建议库 / 方法                             |
| -------------------- | ---------------------------------------------------------- | ------------------------------------ |
| **M2-1　SQLite Repo** | 用 SQLAlchemy 2.0 ORM；表设计保持与 Domain 一致                      | `SQLModel` 可减少样板；事务用 context manager |
| **M2-2　CLI 原型**      | Typer（或 Click 8+）实现<br>`cookmate add-recipe / cook / list` | 丰富命令：`--json` 输出供其他工具消费              |
| **M2-3　事件总线 & 读模型**  | 简易 `EventDispatcher`，先用 Python queue                       | 消费者示例：`CookingLogger`                |
| **M2-4　集成测试**        | Memory & SQLite 同一个 test suite 运行<br>确保 Port 兼容            | pytest fixtures + `--sqlite` flag    |

**完成标志**： 在终端输入一行 `cookmate cook "番茄炒蛋"`，CLI 自动扣库存并落库。

---

## 🌐 阶段 3：API & 前端 Demo

> 目标：**手机/浏览器点一下就能看到剩菜剩料**。

| 里程碑                  | 关键任务                                             | 建议库 / 方法                        |
| -------------------- | ------------------------------------------------ | ------------------------------- |
| **M3-1　FastAPI 层**   | `POST /recipes/` `POST /cook/` `GET /inventory/` | Pydantic v2 DTO；依赖注入用 `Depends` |
| **M3-2　Auth & CORS** | 简单 API-Key 鉴权，支持前端本地调试                           | FastAPI middleware              |
| **M3-3　前端 Demo**     | Vite + React (或 Svelte)；库存列表 + 缺料提示              | 先静态部署 GitHub Pages              |
| **M3-4　Docker & 备份** | 多阶段构建：poetry install → slim image<br>DB 差异化备份脚本  | cron + `sqlite3 .dump`          |

**完成标志**： Demo 网页能展示库存 & 一键生成购物清单（JSON/CSV 下载）。

---

## 🚀 阶段 4：智能化 & 扩展

| 里程碑                | 关键任务                                              | 说明                        |
| ------------------ | ------------------------------------------------- | ------------------------- |
| **M4-1　扫码/语音录入**   | 条形码：集成外部 API 获取食材信息<br>语音：本地离线 ASR + 简易 NLP 匹配食材名 | 先做条形码；语音可插 Home Assistant |
| **M4-2　推荐 & 计划优化** | 根据过期风险、营养均衡给出一周菜单                                 | 涉及多目标优化，可用 OR-Tools       |
| **M4-3　多用户 & 权限**  | 家庭帐号共享同一库存；角色：Owner / Member                      | FastAPI `fastapi-users`   |
| **M4-4　云同步 / 小程序** | SQLite → PostgreSQL / Supabase<br>小程序 H5 套壳       | 取决于你未来商业化方向               |

---

## 🌟　关键技术决策清单

| 维度          | 建议                                                    | 备注             |
| ----------- | ----------------------------------------------------- | -------------- |
| **代码组织**    | Flat-layout → 最终切换到 src-layout（更易隔离第三方脚本）             | 动态导入时相对路径更安全   |
| **类型系统**    | Python 3.12 + `mypy --strict`                         | 报错即红灯          |
| **配置管理**    | Pydantic Settings 或 `dynaconf`，三层：默认 / `.env` / 环境变量  | 先别引入复杂配置中心     |
| **日志 & 监控** | `structlog` JSON 输出；Prometheus fastapi-instrumentator | 生产可直接接 Grafana |
| **测试覆盖率**   | 必须 ≥ 90 % （逻辑核心层），适配器适量                               | 质量门禁：<90 拒绝合并  |
| **版本控制**    | `prefix-semver` 标签（例如 `core/v0.1.0`）                  | 领域层与适配器可分拆 tag |

---

## 🏃‍♂️　下一步可执行 Todo（首两周冲刺）

1. **拆解 MVP**：开 discussion / Issue 把必需功能列表写下来
2. **搭通 CI**：`ruff + pytest + mypy` in GitHub Actions
3. **编写 Domain skeleton**：`domain/recipe/__init__.py` 放 dataclass 雏形
4. **实现 Memory Repo**：接口 + 最小存储字典
5. **写 3–5 个精简单元测试**：覆盖增删改查与库存扣减
6. **Push & 合并**：Merge 回 `main`，CI 绿灯

做到这一步，REPL 里即可体验核心闭环，信心满满再进 SQLite/CLI 迭代。

---

### ⚒️　一些踩坑经验

| 场景         | 小贴士                                                    |
| ---------- | ------------------------------------------------------ |
| SQLite 并发写 | FastAPI + SQLite 用事务 & 单线程连接池；否则 “database is locked”。 |
| 食材单位换算     | “500 g” 与 “0.5 kg” 建议存放 **归一化值** + 单位枚举，展示时再格式化。       |
| 保质期提醒      | 不要单纯比较日期；开封后 & 冷冻/常温的 shelf-life 差异要建配置表。              |
| 条形码库       | 大陆 & 国际条码段不同，建议聚合多个 API 并做缓存。                          |

---

## 💬 最后

这套切分确保你 **先有跑得动的核心逻辑**，再逐层加壳，易于测试与重构；同时留好了微服务 / 云同步的成长空间。按这样推进，**≈ 4 – 6 周** 就能发布 CLI + SQLite 的可用版本；再用 2 – 3 月打磨 API、前端和智能筛选，就能对外小规模试用。祝编码愉快，随时回来交流进展！
